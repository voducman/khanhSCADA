"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const async = require("async");
const chalk_1 = require("chalk");
const fs = require("fs");
const path = require("path");
const _ = require("underscore");
const toolbox_1 = require("./toolbox");
const config = {
    certificateDir: "INVALID",
    forceCA: false,
    pkiDir: "INVALID",
};
const n = toolbox_1.make_path;
const q = toolbox_1.quote;
function construct_CertificateAuthority(cauthority, callback) {
    const caRootDir = cauthority.rootDir;
    function make_folders() {
        toolbox_1.mkdir(caRootDir);
        toolbox_1.mkdir(path.join(caRootDir, "private"));
        toolbox_1.mkdir(path.join(caRootDir, "public"));
        toolbox_1.mkdir(path.join(caRootDir, "certs"));
        toolbox_1.mkdir(path.join(caRootDir, "crl"));
        toolbox_1.mkdir(path.join(caRootDir, "conf"));
    }
    make_folders();
    function construct_default_files() {
        const serial = path.join(caRootDir, "serial");
        if (!fs.existsSync(serial)) {
            fs.writeFileSync(serial, "1000");
        }
        const crlnumber = path.join(caRootDir, "crlnumber");
        if (!fs.existsSync(crlnumber)) {
            fs.writeFileSync(crlnumber, "1000");
        }
        const indexFile = path.join(caRootDir, "index.txt");
        if (!fs.existsSync(indexFile)) {
            fs.writeFileSync(indexFile, "");
        }
    }
    construct_default_files();
    if (fs.existsSync(path.join(caRootDir, "private/cakey.pem")) && !config.forceCA) {
        toolbox_1.debugLog("CA private key already exists ... skipping");
        return callback();
    }
    toolbox_1.displayTitle("Create Certificate Authority (CA)", (err) => {
    });
    const indexFileAttr = path.join(caRootDir, "index.txt.attr");
    if (!fs.existsSync(indexFileAttr)) {
        fs.writeFileSync(indexFileAttr, "unique_subject = no");
    }
    const caConfigFile = cauthority.configFile;
    if (1 || !fs.existsSync(caConfigFile)) {
        let data = toolbox_1.configurationFileTemplate;
        data = data.replace(/%%ROOT_FOLDER%%/, toolbox_1.make_path(caRootDir));
        fs.writeFileSync(caConfigFile, data);
    }
    const subject = "/C=FR/ST=IDF/L=Paris/O=Local NODE-OPCUA Certificate Authority/CN=NodeOPCUA-CA";
    const options = { cwd: caRootDir };
    toolbox_1.processAltNames({});
    const configFile = toolbox_1.generateStaticConfig("conf/caconfig.cnf", options);
    const configOption = " -config " + q(n(configFile));
    const keySize = cauthority.keySize;
    const randomFile = "random.rnd";
    const tasks = [
        (callback) => toolbox_1.displayTitle("Creating random file random.rnd", callback),
        (callback) => toolbox_1.createRandomFileIfNotExist(randomFile, options, callback),
        (callback) => toolbox_1.displayTitle("Generate the CA private Key - " + keySize, callback),
        (callback) => toolbox_1.execute_openssl("genrsa " +
            " -out  private/cakey.pem" +
            (toolbox_1.useRandFile() ? " -rand " + randomFile : "") +
            " " + keySize, options, callback),
        (callback) => toolbox_1.displayTitle("Generate a certificate request for the CA key", callback),
        (callback) => toolbox_1.execute_openssl("req -new" +
            " -sha256 " +
            " -text " +
            " -extensions v3_ca" +
            configOption +
            " -key private/cakey.pem " +
            " -out private/cakey.csr " +
            " -subj \"" + subject + "\"", options, callback),
        (callback) => toolbox_1.displayTitle("Generate CA Certificate (self-signed)", callback),
        (callback) => toolbox_1.execute_openssl(" x509 -sha256 -req -days 3650 " +
            " -text " +
            " -extensions v3_ca" +
            " -extfile " + q(n(configFile)) +
            " -in private/cakey.csr " +
            " -signkey private/cakey.pem " +
            " -out public/cacert.pem", options, callback),
        (callback) => toolbox_1.displaySubtitle("generate initial CRL (Certificate Revocation List)", callback),
        (callback) => toolbox_1.execute_openssl("ca -gencrl " +
            configOption + " -out crl/revocation_list.crl", options, callback),
        (callback) => toolbox_1.displaySubtitle("Produce initial CRL in DER form ", callback),
        (callback) => toolbox_1.execute_openssl("crl " +
            " -in " + q(n(cauthority.revocationList)) +
            " -out  crl/revocation_list.der " +
            " -outform der", options, callback),
        (callback) => toolbox_1.displayTitle("Create Certificate Authority (CA) ---> DONE", callback)
    ];
    async.series(tasks, callback);
}
class CertificateAuthority {
    constructor(options) {
        assert(options.hasOwnProperty("location"));
        assert(options.hasOwnProperty("keySize"));
        this.location = options.location;
        this.keySize = options.keySize || 2048;
    }
    get rootDir() {
        return this.location;
    }
    get configFile() {
        return path.normalize(path.join(this.rootDir, "./conf/caconfig.cnf"));
    }
    get caCertificate() {
        return toolbox_1.make_path(this.rootDir, "./public/cacert.pem");
    }
    get revocationList() {
        return toolbox_1.make_path(this.rootDir, "./crl/revocation_list.crl");
    }
    get caCertificateWithCrl() {
        return toolbox_1.make_path(this.rootDir, "./public/cacertificate_with_crl.pem");
    }
    initialize(callback) {
        assert(_.isFunction(callback));
        construct_CertificateAuthority(this, callback);
    }
    constructCACertificateWithCRL(callback) {
        assert(_.isFunction(callback));
        const cacertWithCRL = this.caCertificateWithCrl;
        if (fs.existsSync(this.revocationList)) {
            fs.writeFileSync(cacertWithCRL, fs.readFileSync(this.caCertificate, "utf8") +
                fs.readFileSync(this.revocationList, "utf8"));
        }
        else {
            fs.writeFileSync(cacertWithCRL, fs.readFileSync(this.caCertificate));
        }
        callback();
    }
    constructCertificateChain(certificate, callback) {
        assert(_.isFunction(callback));
        assert(fs.existsSync(certificate));
        assert(fs.existsSync(this.caCertificate));
        toolbox_1.debugLog(chalk_1.default.yellow("        certificate file :"), chalk_1.default.cyan(certificate));
        fs.writeFileSync(certificate, fs.readFileSync(certificate, "utf8")
            + fs.readFileSync(this.caCertificate, "utf8"));
        callback();
    }
    createSelfSignedCertificate(certificateFile, privateKey, params, callback) {
        assert(typeof privateKey === "string");
        assert(fs.existsSync(privateKey));
        assert(_.isFunction(callback));
        if (!toolbox_1.check_certificate_filename(certificateFile)) {
            return callback();
        }
        toolbox_1.adjustDate(params);
        toolbox_1.adjustApplicationUri(params);
        toolbox_1.processAltNames(params);
        const csrFile = certificateFile + "_csr";
        assert(csrFile);
        const configFile = toolbox_1.generateStaticConfig(this.configFile);
        const options = {
            cwd: this.rootDir,
            openssl_conf: toolbox_1.make_path(configFile)
        };
        const configOption = "";
        const tasks = [];
        tasks.push((callback) => toolbox_1.displaySubtitle("- the certificate signing request", callback));
        tasks.push((callback) => toolbox_1.execute_openssl("req " +
            " -new -sha256 -text " + configOption +
            " -batch -key " + q(n(privateKey)) + " -out " + q(n(csrFile)), options, callback));
        tasks.push((callback) => toolbox_1.displaySubtitle("- creating the self-signed certificate", callback));
        tasks.push((callback) => toolbox_1.execute_openssl("ca " +
            " -selfsign " +
            " -keyfile " + q(n(privateKey)) +
            " -startdate " + toolbox_1.x509Date(params.startDate) +
            " -enddate " + toolbox_1.x509Date(params.endDate) +
            " -batch -out " + q(n(certificateFile)) + " -in " + q(n(csrFile)), options, callback));
        tasks.push((callback) => toolbox_1.displaySubtitle("- dump the certificate for a check", callback));
        tasks.push((callback) => toolbox_1.execute_openssl("x509 -in " + q(n(certificateFile)) + "  -dates -fingerprint -purpose -noout", {}, callback));
        tasks.push((callback) => toolbox_1.displaySubtitle("- verify self-signed certificate", callback));
        tasks.push((callback) => toolbox_1.execute_openssl_no_failure("verify -verbose -CAfile " + q(n(certificateFile)) + " " + q(n(certificateFile)), options, callback));
        tasks.push((callback) => fs.unlink(csrFile, callback));
        async.series(tasks, (err) => {
            callback(err);
        });
    }
    revokeCertificate(certificate, params, callback) {
        assert(_.isFunction(callback));
        const crlReasons = [
            "unspecified", "keyCompromise", "CACompromise",
            "affiliationChanged", "superseded", "cessationOfOperation",
            "certificateHold", "removeFromCRL"
        ];
        const configFile = toolbox_1.generateStaticConfig("conf/caconfig.cnf", { cwd: this.rootDir });
        const options = {
            cwd: this.rootDir,
            openssl_conf: toolbox_1.make_path(configFile)
        };
        assert(fs.existsSync(process.env["OPENSSL_CONF"]));
        const configOption = " -config " + q(n(configFile));
        const reason = params.reason || "keyCompromise";
        assert(crlReasons.indexOf(reason) >= 0);
        const tasks = [
            (callback) => toolbox_1.displayTitle("Revoking certificate  " + certificate, callback),
            (callback) => toolbox_1.displaySubtitle("Revoke certificate", callback),
            (callback) => toolbox_1.execute_openssl_no_failure("ca " + configOption + " -revoke " + q(certificate) +
                " -crl_reason " + reason, options, callback),
            (callback) => toolbox_1.displaySubtitle("regenerate CRL (Certificate Revocation List)", callback),
            (callback) => toolbox_1.execute_openssl("ca -gencrl " + configOption + " -out crl/revocation_list.crl", options, callback),
            (callback) => toolbox_1.displaySubtitle("Display (Certificate Revocation List)", callback),
            (callback) => toolbox_1.execute_openssl("crl " +
                " -in " +
                q(n(this.revocationList)) +
                " -text " +
                " -noout", options, callback),
            (callback) => toolbox_1.displaySubtitle("Verify that certificate is revoked  ", callback),
            (callback) => {
                toolbox_1.execute_openssl_no_failure("verify -verbose" +
                    " -CRLfile " +
                    q(n(this.revocationList)) +
                    " -CAfile " + q(n(this.caCertificate)) + " -crl_check " + q(n(certificate)), options, (err, output) => {
                    callback();
                });
            },
            (callback) => toolbox_1.displaySubtitle("Produce CRL in DER form ", callback),
            (callback) => toolbox_1.execute_openssl("crl " +
                " -in " +
                q(n(this.revocationList)) +
                " -out " +
                "crl/revocation_list.der " +
                " -outform der", options, callback),
            (callback) => toolbox_1.displaySubtitle("Produce CRL in PEM form ", callback),
            (callback) => toolbox_1.execute_openssl("crl " +
                " -in " +
                q(n(this.revocationList)) +
                " -out " +
                "crl/revocation_list.pem " +
                " -outform pem", options, callback)
        ];
        async.series(tasks, callback);
    }
    signCertificateRequest(certificate, certificateSigningRequestFilename, params, callback) {
        if (!callback) {
            throw new Error("Internal Error");
        }
        assert(fs.existsSync(certificateSigningRequestFilename));
        assert(_.isFunction(callback));
        if (!toolbox_1.check_certificate_filename(certificate)) {
            return callback(null);
        }
        toolbox_1.adjustDate(params);
        toolbox_1.adjustApplicationUri(params);
        toolbox_1.processAltNames(params);
        const options = { cwd: this.rootDir };
        const configFile = toolbox_1.generateStaticConfig("conf/caconfig.cnf", options);
        const configOption = " -config " + configFile;
        const tasks = [];
        tasks.push((callback) => toolbox_1.displaySubtitle("- then we ask the authority to sign the certificate signing request", callback));
        tasks.push((callback) => toolbox_1.execute_openssl("ca " +
            configOption +
            " -startdate " + toolbox_1.x509Date(params.startDate) +
            " -enddate " + toolbox_1.x509Date(params.endDate) +
            " -batch -out " + q(n(certificate)) + " -in " + q(n(certificateSigningRequestFilename)), options, callback));
        tasks.push((callback) => toolbox_1.displaySubtitle("- dump the certificate for a check", callback));
        tasks.push((callback) => toolbox_1.execute_openssl("x509 -in " + q(n(certificate)) + "  -dates -fingerprint -purpose -noout", options, callback));
        tasks.push((callback) => toolbox_1.displaySubtitle("- construct CA certificate with CRL", callback));
        tasks.push((callback) => {
            this.constructCACertificateWithCRL(callback);
        });
        tasks.push((callback) => toolbox_1.displaySubtitle("- construct certificate chain", callback));
        tasks.push((callback) => {
            this.constructCertificateChain(certificate, callback);
        });
        tasks.push((callback) => toolbox_1.displaySubtitle("- verify certificate against the root CA", callback));
        tasks.push((callback) => {
            this.verifyCertificate(certificate, callback);
        });
        async.series(tasks, (err) => {
            if (err) {
                return callback(err);
            }
            callback(null, certificate);
        });
    }
    verifyCertificate(certificate, callback) {
        const isImplemented = false;
        if (isImplemented) {
            const options = { cwd: this.rootDir };
            const configFile = toolbox_1.generateStaticConfig("conf/caconfig.cnf", options);
            toolbox_1.setEnv("OPENSSL_CONF", toolbox_1.make_path(configFile));
            const configOption = " -config " + configFile;
            toolbox_1.execute_openssl_no_failure("verify -verbose " +
                " -CAfile " + q(n(this.caCertificateWithCrl)) +
                " " + q(n(certificate)), options, (err) => {
                callback(err ? err : undefined);
            });
        }
        else {
            return callback();
        }
    }
}
exports.CertificateAuthority = CertificateAuthority;
const thenify = require("thenify");
const opts = { multiArgs: false };
CertificateAuthority.prototype.initialize
    = thenify.withCallback(CertificateAuthority.prototype.initialize, opts);
CertificateAuthority.prototype.constructCACertificateWithCRL
    = thenify.withCallback(CertificateAuthority.prototype.constructCACertificateWithCRL, opts);
CertificateAuthority.prototype.constructCertificateChain
    = thenify.withCallback(CertificateAuthority.prototype.constructCertificateChain, opts);
CertificateAuthority.prototype.createSelfSignedCertificate
    = thenify.withCallback(CertificateAuthority.prototype.createSelfSignedCertificate, opts);
CertificateAuthority.prototype.revokeCertificate
    = thenify.withCallback(CertificateAuthority.prototype.revokeCertificate, opts);
CertificateAuthority.prototype.verifyCertificate
    = thenify.withCallback(CertificateAuthority.prototype.verifyCertificate, opts);
CertificateAuthority.prototype.signCertificateRequest
    = thenify.withCallback(CertificateAuthority.prototype.signCertificateRequest, opts);
//# sourceMappingURL=certificate_authority.js.map