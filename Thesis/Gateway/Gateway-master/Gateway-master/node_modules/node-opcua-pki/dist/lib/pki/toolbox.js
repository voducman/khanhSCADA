"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const async = require("async");
const byline = require("byline");
const chalk_1 = require("chalk");
const child_process = require("child_process");
const fs = require("fs");
const os = require("os");
const path = require("path");
const _ = require("underscore");
const install_prerequisite_1 = require("../misc/install_prerequisite");
const subject_1 = require("../misc/subject");
const ca_config_template_cnf_1 = require("./templates/ca_config_template.cnf");
const simple_config_template_cnf_1 = require("./templates/simple_config_template.cnf");
const exportedEnvVars = {};
function quote(str) {
    return "\"" + str + "\"";
}
exports.quote = quote;
exports.g_config = {
    opensslVersion: "unset",
    silent: false,
};
const displayError = true;
function debugLog(...args) {
}
exports.debugLog = debugLog;
let opensslPath;
function find_openssl(callback) {
    install_prerequisite_1.get_openssl_exec_path((err, _opensslPath) => {
        opensslPath = _opensslPath;
        callback(err, opensslPath);
    });
}
exports.find_openssl = find_openssl;
function mkdir(folder) {
    if (!fs.existsSync(folder)) {
        if (!exports.g_config.silent) {
            console.log(chalk_1.default.white(" .. constructing "), folder);
        }
        fs.mkdirSync(folder);
    }
}
exports.mkdir = mkdir;
function setEnv(varName, value) {
    if (!exports.g_config.silent) {
        console.log("          set " + varName + "=" + value);
    }
    exportedEnvVars[varName] = value;
    if (["OPENSSL_CONF"].indexOf(varName) >= 0) {
        process.env[varName] = value;
    }
}
exports.setEnv = setEnv;
function hasEnv(varName) {
    return exportedEnvVars.hasOwnProperty(varName);
}
exports.hasEnv = hasEnv;
function execute(cmd, options, callback) {
    assert(_.isFunction(callback));
    options.cwd = options.cwd || process.cwd();
    if (!exports.g_config.silent) {
        console.log(chalk_1.default.cyan("                  CWD         "), options.cwd);
    }
    const outputs = [];
    const child = child_process.exec(cmd, {
        cwd: options.cwd
    }, (err) => {
        if (err) {
            if (!options.hideErrorMessage) {
                const fence = "###########################################";
                console.error(chalk_1.default.bgWhiteBright.redBright(`${fence} OPENSSL ERROR ${fence}`));
                console.error(chalk_1.default.bgWhiteBright.redBright("CWD = " + options.cwd));
                console.error(chalk_1.default.bgWhiteBright.redBright(err.message));
                console.error(chalk_1.default.bgWhiteBright.redBright(`${fence} OPENSSL ERROR ${fence}`));
            }
        }
        callback(err, outputs.join(""));
    });
    const stream2 = byline(child.stdout);
    stream2.on("data", (line) => {
        outputs.push(line + "\n");
    });
    if (!exports.g_config.silent) {
        const stream1 = byline(child.stderr);
        stream1.on("data", (line) => {
            line = line.toString();
            if (displayError) {
                process.stdout.write(chalk_1.default.white("        stderr ") + chalk_1.default.red(line) + "\n");
            }
        });
        stream2.on("data", (line) => {
            line = line.toString();
            process.stdout.write(chalk_1.default.white("        stdout ") + chalk_1.default.whiteBright(line) + "\n");
        });
    }
}
exports.execute = execute;
function useRandFile() {
    if (exports.g_config.opensslVersion && exports.g_config.opensslVersion.toLowerCase().indexOf("libressl") > -1) {
        return false;
    }
    return true;
}
exports.useRandFile = useRandFile;
function openssl_require2DigitYearInDate() {
    if (!exports.g_config.opensslVersion) {
        throw new Error("openssl_require2DigitYearInDate : openssl version is not known:" +
            "  please call ensure_openssl_installed(callback)");
    }
    return exports.g_config.opensslVersion.match(/OpenSSL 0\.9/);
}
exports.g_config.opensslVersion = "";
function ensure_openssl_installed(callback) {
    assert(_.isFunction(callback));
    if (!opensslPath) {
        return find_openssl((err) => {
            if (err) {
                return callback(err);
            }
            execute_openssl("version", { cwd: "." }, (err, outputs) => {
                if (err) {
                    return callback(err);
                }
                exports.g_config.opensslVersion = outputs.trim();
                console.log("OpenSSL version : ", exports.g_config.opensslVersion);
                callback(err ? err : undefined);
            });
        });
    }
    else {
        return callback();
    }
}
exports.ensure_openssl_installed = ensure_openssl_installed;
function getTempFolder() {
    return os.tmpdir();
}
function execute_openssl(cmd, options, callback) {
    const empty_config_file = n(getTempFolder(), "empty_config.cnf");
    if (!fs.existsSync(empty_config_file)) {
        fs.writeFileSync(empty_config_file, "# empty config file");
    }
    assert(_.isFunction(callback));
    options = options || {};
    options.openssl_conf = options.openssl_conf || empty_config_file;
    assert(options.openssl_conf);
    setEnv("OPENSSL_CONF", options.openssl_conf);
    if (!exports.g_config.silent) {
        console.log(chalk_1.default.cyan("                  OPENSSL_CONF"), process.env.OPENSSL_CONF);
        console.log(chalk_1.default.cyan("                  RANDFILE    "), process.env.RANDFILE);
        console.log(chalk_1.default.cyan("                  CMD         openssl "), chalk_1.default.cyanBright(cmd));
    }
    ensure_openssl_installed((err) => {
        if (err) {
            return callback(err);
        }
        execute(quote(opensslPath) + " " + cmd, options, callback);
    });
}
exports.execute_openssl = execute_openssl;
function execute_openssl_no_failure(cmd, options, callback) {
    options = options || {};
    options.hideErrorMessage = true;
    execute_openssl(cmd, options, (err, output) => {
        if (err) {
            if (false) {
                console.log(" (ignored error =  ERROR : )", err.message);
            }
        }
        callback(null, output);
    });
}
exports.execute_openssl_no_failure = execute_openssl_no_failure;
function displayChapter(str, callback) {
    const l = "                                                                                               ";
    console.log(chalk_1.default.bgWhite(l) + " ");
    str = ("        " + str + l).substring(0, l.length);
    console.log(chalk_1.default.bgWhite.cyan(str));
    console.log(chalk_1.default.bgWhite(l) + " ");
    if (callback) {
        callback();
    }
}
exports.displayChapter = displayChapter;
function displayTitle(str, callback) {
    if (!exports.g_config.silent) {
        console.log("");
        console.log(chalk_1.default.yellowBright(str));
        console.log(chalk_1.default.yellow(new Array(str.length + 1).join("=")), "\n");
    }
    if (callback) {
        callback();
    }
}
exports.displayTitle = displayTitle;
function displaySubtitle(str, callback) {
    if (!exports.g_config.silent) {
        console.log("");
        console.log("    " + chalk_1.default.yellowBright(str));
        console.log("    " + chalk_1.default.white(new Array(str.length + 1).join("-")), "\n");
    }
    if (callback) {
        callback();
    }
}
exports.displaySubtitle = displaySubtitle;
function getEnvironmentVarNames() {
    return Object.keys(exportedEnvVars).map((varName) => {
        return { key: varName, pattern: "\\$ENV\\:\\:" + varName };
    });
}
exports.getEnvironmentVarNames = getEnvironmentVarNames;
function generateStaticConfig(configPath, options) {
    const prePath = options && options.cwd || "";
    const staticConfigPath = configPath + ".tmp";
    let staticConfig = fs.readFileSync(path.join(prePath, configPath), { encoding: "utf8" });
    for (const envVar of getEnvironmentVarNames()) {
        staticConfig = staticConfig.replace(new RegExp(envVar.pattern, "gi"), exportedEnvVars[envVar.key]);
    }
    fs.writeFileSync(path.join(prePath, staticConfigPath), staticConfig);
    return staticConfigPath;
}
exports.generateStaticConfig = generateStaticConfig;
const q = quote;
function make_path(folderName, filename) {
    let s;
    if (filename) {
        s = path.join(path.normalize(folderName), filename);
    }
    else {
        assert(folderName);
        s = folderName;
    }
    s = s.replace(/\\/g, "/");
    return s;
}
exports.make_path = make_path;
const n = make_path;
function getPublicKeyFromPrivateKey(privateKeyFilename, publicKeyFilename, callback) {
    assert(fs.existsSync(privateKeyFilename));
    execute_openssl("rsa -pubout -in " + q(n(privateKeyFilename)) + " -out " + q(n(publicKeyFilename)), {}, callback);
}
exports.getPublicKeyFromPrivateKey = getPublicKeyFromPrivateKey;
function getPublicKeyFromCertificate(certificateFilename, publicKeyFilename, callback) {
    assert(fs.existsSync(certificateFilename));
    execute_openssl("x509 -pubkey -in " +
        q(n(certificateFilename)) + " > " + q(n(publicKeyFilename)), {}, callback);
}
exports.getPublicKeyFromCertificate = getPublicKeyFromCertificate;
function createPrivateKey(privateKeyFilename, keyLength, callback) {
    if (useRandFile()) {
    }
    assert([1024, 2048, 3072, 4096].indexOf(keyLength) >= 0);
    const randomFile = exportedEnvVars.RANDFILE ? q(n(exportedEnvVars.RANDFILE)) : "random.rnd";
    const tasks = [
        (callback) => createRandomFileIfNotExist(randomFile, {}, callback),
        (callback) => {
            execute_openssl("genrsa " +
                " -out " + q(n(privateKeyFilename)) +
                (useRandFile() ? " -rand " + randomFile : "") +
                " " + keyLength, {}, (err) => {
                callback(err ? err : undefined);
            });
        }
    ];
    async.series(tasks, callback);
}
exports.createPrivateKey = createPrivateKey;
function createRandomFile(randomFile, options, callback) {
    if (!useRandFile()) {
        return callback();
    }
    execute_openssl("rand " +
        " -out " + randomFile + " -hex 256", options, (err) => {
        callback(err ? err : undefined);
    });
}
exports.createRandomFile = createRandomFile;
function createRandomFileIfNotExist(randomFile, options, callback) {
    const randomFilePath = options.cwd ? path.join(options.cwd, randomFile) : randomFile;
    fs.exists(randomFilePath, (exists) => {
        if (exists) {
            console.log(chalk_1.default.yellow("         randomFile"), chalk_1.default.cyan(randomFile), chalk_1.default.yellow(" already exists => skipping"));
            return callback();
        }
        else {
            createRandomFile(randomFile, options, callback);
        }
    });
}
exports.createRandomFileIfNotExist = createRandomFileIfNotExist;
function createCertificateSigningRequest(certificateSigningRequestFilename, params, callback) {
    assert(params);
    assert(params.rootDir);
    assert(params.configFile);
    assert(params.privateKey);
    assert(_.isString(params.privateKey));
    assert(fs.existsSync(params.configFile), "config file must exist");
    assert(fs.existsSync(params.privateKey), "Private key must exist");
    assert(fs.existsSync(params.rootDir), "RootDir key must exist");
    assert(_.isString(certificateSigningRequestFilename));
    processAltNames(params);
    const configFile = generateStaticConfig(params.configFile);
    const options = { cwd: params.rootDir, openssl_conf: configFile };
    const configOption = " -config " + q(n(configFile));
    async.series([
        (callback) => {
            displaySubtitle("- Creating a Certificate Signing Request", callback);
        },
        (callback) => {
            execute_openssl("req -new" +
                "  -sha256 " +
                " -batch " +
                " -text " +
                configOption +
                " -key " + q(n(params.privateKey)) +
                " -out " + q(n(certificateSigningRequestFilename)), options, (err) => {
                callback(err ? err : undefined);
            });
        }
    ], (err) => callback(err));
}
exports.createCertificateSigningRequest = createCertificateSigningRequest;
function x509Date(date) {
    const Y = date.getUTCFullYear();
    const M = date.getUTCMonth() + 1;
    const D = date.getUTCDate();
    const h = date.getUTCHours();
    const m = date.getUTCMinutes();
    const s = date.getUTCSeconds();
    function w(s, l) {
        return ("00000" + s).substr(-l, l);
    }
    if (openssl_require2DigitYearInDate()) {
        return w(Y, 2) + w(M, 2) + w(D, 2) + w(h, 2) + w(m, 2) + w(s, 2) + "Z";
    }
    else {
        return w(Y, 4) + w(M, 2) + w(D, 2) + w(h, 2) + w(m, 2) + w(s, 2) + "Z";
    }
}
exports.x509Date = x509Date;
function adjustDate(params) {
    assert(params instanceof Object);
    params.startDate = params.startDate || new Date();
    assert(params.startDate instanceof Date);
    params.validity = params.validity || 365;
    params.endDate = new Date(params.startDate.getTime());
    params.endDate.setDate(params.startDate.getDate() + params.validity);
    assert(params.endDate instanceof Date);
    assert(params.startDate instanceof Date);
    if (!exports.g_config.silent) {
        console.log(" start Date ", params.startDate.toUTCString(), x509Date(params.startDate));
        console.log(" end   Date ", params.endDate.toUTCString(), x509Date(params.endDate));
    }
}
exports.adjustDate = adjustDate;
function adjustApplicationUri(params) {
    const applicationUri = params.applicationUri;
    assert(typeof applicationUri === "string");
    assert(applicationUri.length <= 64, "Openssl doesn't support urn with length greater than 64 ");
}
exports.adjustApplicationUri = adjustApplicationUri;
function check_certificate_filename(certificateFile) {
    assert(typeof certificateFile === "string");
    if (fs.existsSync(certificateFile) && !exports.g_config.force) {
        console.log(chalk_1.default.yellow("        certificate ") +
            chalk_1.default.cyan(certificateFile) + chalk_1.default.yellow(" already exists => do not overwrite"));
        return false;
    }
    return true;
}
exports.check_certificate_filename = check_certificate_filename;
function processAltNames(params) {
    params.dns = params.dns || [];
    params.ip = params.ip || [];
    let subjectAltName = [];
    subjectAltName.push("URI:" + params.applicationUri);
    subjectAltName = [].concat(subjectAltName, params.dns.map((d) => "DNS:" + d));
    subjectAltName = [].concat(subjectAltName, params.ip.map((d) => "IP:" + d));
    const subjectAltNameString = subjectAltName.join(", ");
    setEnv("ALTNAME", subjectAltNameString);
}
exports.processAltNames = processAltNames;
function createSelfSignCertificate(certificate, params, callback) {
    assert(fs.existsSync(params.configFile));
    assert(fs.existsSync(params.rootDir));
    assert(fs.existsSync(params.privateKey));
    if (!params.subject) {
        return callback(new Error("Missing subject"));
    }
    assert(_.isString(params.applicationUri));
    assert(_.isArray(params.dns));
    processAltNames(params);
    adjustDate(params);
    assert(params.hasOwnProperty("validity"));
    let subject = new subject_1.Subject(params.subject);
    subject = subject.toString();
    const certificateRequestFilename = certificate + ".csr";
    const configFile = generateStaticConfig(params.configFile);
    const configOption = " -config " + q(n(configFile));
    const tasks = [
        (callback) => {
            displayTitle("Generate a certificate request", callback);
        },
        (callback) => {
            execute_openssl("req -new" +
                " -sha256 " +
                " -text " +
                " -extensions v3_ca" +
                configOption +
                " -key " + q(n(params.privateKey)) +
                " -out " + q(n(certificateRequestFilename)) +
                " -subj \"" + subject + "\"", {}, callback);
        },
        (callback) => {
            displayTitle("Generate Certificate (self-signed)", callback);
        },
        (callback) => {
            execute_openssl(" x509 -req " +
                " -days " + params.validity +
                " -extensions v3_ca" +
                " -extfile " + q(n(configFile)) +
                " -in " + q(n(certificateRequestFilename)) +
                " -signkey " + q(n(params.privateKey)) +
                " -text " +
                " -out " + q(certificate) +
                " -text ", {}, callback);
        },
        (callback) => {
            fs.unlink(certificateRequestFilename, callback);
        }
    ];
    async.series(tasks, callback);
}
exports.createSelfSignCertificate = createSelfSignCertificate;
exports.configurationFileTemplate = ca_config_template_cnf_1.default;
exports.configurationFileSimpleTemplate = simple_config_template_cnf_1.default;
function dumpCertificate(certificate, callback) {
    assert(fs.existsSync(certificate));
    assert(_.isFunction(callback));
    execute_openssl("x509 " +
        " -in " + q(n(certificate)) +
        " -text " +
        " -noout", {}, callback);
}
exports.dumpCertificate = dumpCertificate;
function toDer(certificatePem, callback) {
    assert(fs.existsSync(certificatePem));
    const certificateDer = certificatePem.replace(".pem", ".der");
    execute_openssl("x509  " +
        " -outform der " +
        " -in " + certificatePem +
        " -out " + certificateDer, {}, callback);
}
exports.toDer = toDer;
function fingerprint(certificatePem, callback) {
    assert(fs.existsSync(certificatePem));
    execute_openssl("x509  " +
        " -fingerprint " +
        " -noout " +
        " -in " + certificatePem, {}, callback);
}
exports.fingerprint = fingerprint;
//# sourceMappingURL=toolbox.js.map