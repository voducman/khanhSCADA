"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const async = require("async");
const chalk_1 = require("chalk");
const fs = require("fs");
const path = require("path");
const _ = require("underscore");
const node_opcua_crypto_1 = require("node-opcua-crypto");
const toolbox_1 = require("./toolbox");
const walk = require("walk");
class CertificateManager {
    constructor(options) {
        options.keySize = options.keySize || 2048;
        assert(options.hasOwnProperty("location"));
        assert(options.hasOwnProperty("keySize"));
        this.location = toolbox_1.make_path(options.location, "");
        this.keySize = options.keySize;
        toolbox_1.mkdir(options.location);
        if (!fs.existsSync(this.location)) {
            throw new Error("CertificateManager cannot access location " + this.location);
        }
        this._thumbs = {
            rejected: {},
            trusted: {},
        };
    }
    get configFile() {
        return path.join(this.rootDir, "own/openssl.cnf");
    }
    get rootDir() {
        return this.location;
    }
    get privateKey() {
        return path.join(this.rootDir, "own/private/private_key.pem");
    }
    get randomFile() {
        return path.join(this.rootDir, "own/private/random.rnd");
    }
    getCertificateStatus(certificate, ...args) {
        const callback = args[0];
        this.initialize(() => {
            this._getCertificateStatus(certificate, (err, status) => {
                if (err) {
                    return callback(err);
                }
                if (status === "unknown") {
                    assert(certificate instanceof Buffer);
                    const thumbprint = node_opcua_crypto_1.makeSHA1Thumbprint(certificate).toString("hex");
                    const certificateName = path.join(this.rootDir, "rejected", thumbprint + ".pem");
                    const pem = node_opcua_crypto_1.toPem(certificate, "CERTIFICATE");
                    fs.writeFile(certificateName, pem, (err) => {
                        if (err) {
                            return callback(err);
                        }
                        status = "rejected";
                        return callback(null, status);
                    });
                    return;
                }
                return callback(null, status);
            });
        });
    }
    rejectCertificate(certificate, ...args) {
        const callback = args[0];
        this._moveCertificate(certificate, "rejected", callback);
    }
    trustCertificate(certificate, ...args) {
        const callback = args[0];
        this._moveCertificate(certificate, "trusted", callback);
    }
    verifyCertificate(certificate, callback) {
        if (!certificate) {
            return callback(new Error("BadSecurityChecksFailed"));
        }
        const cert = node_opcua_crypto_1.exploreCertificateInfo(certificate);
        const now = new Date();
        async.series([
            (callback) => {
                if (cert.notBefore.getTime() > now.getTime()) {
                    toolbox_1.debugLog(chalk_1.default.red("certificate is invalid : certificate is not active yet !") +
                        "  not before date =" + cert.notBefore);
                    return callback(new Error("BadCertificateTimeInvalid"));
                }
                else {
                    return callback();
                }
            },
            (callback) => {
                if (cert.notAfter.getTime() <= now.getTime()) {
                    toolbox_1.debugLog(chalk_1.default.red("certificate is invalid : certificate has expired !")
                        + " not after date =" + cert.notAfter);
                    return callback(new Error("BadCertificateTimeInvalid"));
                }
                else {
                    return callback();
                }
            },
            (callback) => {
                this._getCertificateStatus(certificate, (err, status) => {
                    if (err) {
                        return callback(err);
                    }
                    if (status === "rejected") {
                        return callback(new Error("BadCertificateUntrusted"));
                    }
                    else if (status === "trusted") {
                        return callback();
                    }
                    assert(status === "unknown");
                    return callback(new Error("BadCertificateUntrusted"));
                });
            },
            (callback) => {
                return callback();
            },
            (callback) => {
                return callback();
            },
            (callback) => {
                return callback();
            }
        ], callback);
    }
    initialize(...args) {
        const callback = args[0];
        const pkiDir = this.location;
        toolbox_1.mkdir(pkiDir);
        toolbox_1.mkdir(path.join(pkiDir, "own"));
        toolbox_1.mkdir(path.join(pkiDir, "own/certs"));
        toolbox_1.mkdir(path.join(pkiDir, "own/private"));
        toolbox_1.mkdir(path.join(pkiDir, "trusted"));
        toolbox_1.mkdir(path.join(pkiDir, "rejected"));
        toolbox_1.ensure_openssl_installed(() => {
            fs.writeFileSync(this.configFile, toolbox_1.configurationFileSimpleTemplate);
            fs.exists(this.privateKey, (exists) => {
                if (!exists) {
                    toolbox_1.debugLog("generating private key ...");
                    toolbox_1.setEnv("RANDFILE", this.randomFile);
                    toolbox_1.createPrivateKey(this.privateKey, this.keySize, (err) => {
                        return callback(err);
                    });
                }
                else {
                    toolbox_1.debugLog("private key already exists ... skipping");
                    return callback();
                }
            });
        });
    }
    createSelfSignedCertificate(params, ...args) {
        const callback = args[0];
        const self = this;
        assert(_.isString(params.applicationUri), "expecting applicationUri");
        if (!fs.existsSync(self.privateKey)) {
            return callback(new Error("Cannot find private key " + self.privateKey));
        }
        let certificateFilename = path.join(self.rootDir, "own/certs/self_signed_certificate.pem");
        certificateFilename = params.outputFile || certificateFilename;
        const _params = params;
        _params.rootDir = self.rootDir;
        _params.configFile = self.configFile;
        _params.privateKey = self.privateKey;
        toolbox_1.createSelfSignCertificate(certificateFilename, _params, callback);
    }
    createCertificateRequest(params, callback) {
        assert(params);
        assert(_.isFunction(callback));
        const _params = params;
        if (_params.hasOwnProperty("rootDir")) {
            throw new Error("rootDir should not be specified ");
        }
        assert(!_params.rootDir);
        assert(!_params.configFile);
        assert(!_params.privateKey);
        _params.rootDir = this.rootDir;
        _params.configFile = this.configFile;
        _params.privateKey = this.privateKey;
        const now = new Date();
        const today = now.toISOString().slice(0, 10) + "_" + now.getTime();
        const certificateSigningRequestFilename = path.join(this.rootDir, "own/certs", "certificate_" + today + ".csr");
        toolbox_1.createCertificateSigningRequest(certificateSigningRequestFilename, _params, (err) => {
            return callback(err, certificateSigningRequestFilename);
        });
    }
    _getCertificateStatus(certificate, callback) {
        assert(certificate instanceof Buffer);
        const thumbprint = node_opcua_crypto_1.makeSHA1Thumbprint(certificate).toString("hex");
        toolbox_1.debugLog("thumbprint ", thumbprint);
        this._readCertificates((err) => {
            if (err) {
                return callback(err);
            }
            if (this._thumbs.rejected.hasOwnProperty(thumbprint)) {
                return callback(null, "rejected");
            }
            if (this._thumbs.trusted.hasOwnProperty(thumbprint)) {
                return callback(null, "trusted");
            }
            return callback(null, "unknown");
        });
    }
    _moveCertificate(certificate, newStatus, callback) {
        assert(certificate instanceof Buffer);
        const thumbprint = node_opcua_crypto_1.makeSHA1Thumbprint(certificate).toString("hex");
        this.getCertificateStatus(certificate, (err, status) => {
            if (err) {
                return callback(err);
            }
            if (status !== newStatus) {
                const certificateSrc = path.join(this.rootDir, status, thumbprint + ".pem");
                const certificateDest = path.join(this.rootDir, newStatus, thumbprint + ".pem");
                fs.rename(certificateSrc, certificateDest, (err) => {
                    delete this._thumbs[status][thumbprint];
                    this._thumbs[newStatus][thumbprint] = 1;
                    return callback(err);
                });
            }
            else {
                return callback();
            }
        });
    }
    _readCertificates(callback) {
        function readThumbprint(certificateFilename) {
            const certificate = node_opcua_crypto_1.readCertificate(certificateFilename);
            const thumbprint = node_opcua_crypto_1.makeSHA1Thumbprint(certificate).toString("hex");
            return thumbprint;
        }
        function _f(folder, index, callback) {
            const walker = walk.walk(folder, { followLinks: false });
            walker.on("file", (root, stat, next) => {
                const filename = path.join(root, stat.name);
                try {
                    const thumbprint = readThumbprint(filename);
                    index[thumbprint] = 1;
                }
                catch (err) {
                    toolbox_1.debugLog("err : ", err.message);
                }
                next();
            });
            walker.on("end", () => {
                return callback();
            });
        }
        async.series([
            (callback) => {
                _f.bind(this, path.join(this.rootDir, "trusted"), this._thumbs.trusted)
                    .call(null, callback);
            },
            (callback) => {
                _f.bind(this, path.join(this.rootDir, "rejected"), this._thumbs.rejected)
                    .call(null, callback);
            }
        ], (err) => callback(err));
    }
}
exports.CertificateManager = CertificateManager;
const thenify = require("thenify");
const opts = { multiArgs: false };
CertificateManager.prototype.rejectCertificate = thenify.withCallback(CertificateManager.prototype.rejectCertificate, opts);
CertificateManager.prototype.trustCertificate = thenify.withCallback(CertificateManager.prototype.trustCertificate, opts);
CertificateManager.prototype.createSelfSignedCertificate = thenify.withCallback(CertificateManager.prototype.createSelfSignedCertificate, opts);
CertificateManager.prototype.createCertificateRequest = thenify.withCallback(CertificateManager.prototype.createCertificateRequest, opts);
CertificateManager.prototype.initialize = thenify.withCallback(CertificateManager.prototype.initialize, opts);
CertificateManager.prototype.getCertificateStatus = thenify.withCallback(CertificateManager.prototype.getCertificateStatus, opts);
//# sourceMappingURL=certificate_manager.js.map